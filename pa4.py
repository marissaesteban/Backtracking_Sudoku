# File: pa4.py
# Author: Gabe Krishnadasan and Marissa Esteban    
# Date: 4/30/2023
# Description: 

from math import sqrt
from copy import copy, deepcopy
import queue

def solve(size, filename):
    """
    Solves the Sudoku problem specified in input file filename.
    The size of the problem is size.  (For example, for a 9 x 9 Sudoku,
    size is 9.)
    Returns a tuple of size 2.  The first element is a nested list containing
    the solution to the problem (row is the first index, col the second).
    The second element of the tuple is the number of nodes in the state space
    tree that were generated by your solution.
    """

    fourby_dict = {'1': 1, '2': 2, '3': 3, '4': 4,'5': 5, '6': 6,'7': 7, '8': 8,'9': 9, 'A': 10,'B': 11, 'C': 12,'D': 13, 'E': 14,'F': 15, 'G': 16}
    fourby_dict_rev = {'1': '1', '2': '2', '3': '3', '4': '4', '5': '5', '6': '6', '7': '7', '8': '8', '9': '9', '10': 'A', '11': 'B', '12': 'C', '13': 'D', '14': 'E', '15': 'F', '16': 'G'}
    letters = "ABCDEFGHIJKLMNOPQRSTUVWXY"
    count = 1
    fiveby_dict = {}
    fiveby_dict_rev = {}
    for letter in letters:
        fiveby_dict[letter] = count
        fiveby_dict_rev[str(count)] = letter
        count+=1

    sudoku, no_value = read_input_file(filename, size)

    # convert sudoku grid into numbers
    for r in range(size):
        for c in range(size):            
            if sudoku[r][c] != None:
                if size == 16:
                    sudoku[r][c] = fourby_dict[sudoku[r][c]]
                if size == 25:
                    sudoku[r][c] = fiveby_dict[sudoku[r][c]]

    # setting the possible values 3d array to default
    sudoku_possible_vals = []
    for r in range(size):
        temp = []
        for c in range(size):
            if sudoku[r][c] == None:
                temp2 = set(i for i in range(1, size+1))
            else:
                temp2 = set()
            temp.append(temp2)

        sudoku_possible_vals.append(temp)

    only_one_possible = get_possible_vals(sudoku, size, sudoku_possible_vals, no_value)  
    cutoffs_for_sudoku(sudoku, sudoku_possible_vals, no_value, size, only_one_possible)

    #Want to sort no value, from greatest possible vals to least possible vals, and then just pop within recursive  
    
    sudoku, num_nodes = sudoku_recursive(sudoku, sudoku_possible_vals, no_value, 0, size)

    if sudoku == None:
        return sudoku, num_nodes

    for r in range(size):
        for c in range(size):            
            if sudoku[r][c] != None:
                if size == 16:
                    sudoku[r][c] = fourby_dict_rev[str(sudoku[r][c])]
                if size == 25:
                    sudoku[r][c] = fiveby_dict_rev[str(sudoku[r][c])]

    return sudoku, num_nodes


def sudoku_recursive(sudoku, sudoku_possible_vals, no_value, num_nodes, size):
    """
    grid: 2d array as [row][col] with set values
    no_value: a list of tuples that indicate squares with no values
    i: no_value[i] is the square that we are assigning in this recursive call
    
    Returns the new grid and how many instances of the function have been called from this recursive node 
    """
    num_nodes += 1

    if len(no_value) == 0:
        return sudoku, num_nodes
    else:
        row, col = find_smallest_possible(sudoku_possible_vals, no_value)
        possible = sudoku_possible_vals[row][col]

        if len(possible) != 0:
            for i in range(len(possible)):
                sudoku_c = deepcopy(sudoku)
                sudoku_possible_vals_c = deepcopy(sudoku_possible_vals)    
                no_value_c = deepcopy(no_value)

                #O(n) for casting maybe?? we can change this
                sudoku_c[row][col] = str(list(possible)[i])
                sudoku_possible_vals_c[row][col] = set()
                

                only_one_possible = get_possible_vals(sudoku_c, len(sudoku_c), sudoku_possible_vals_c, no_value_c)
                update_possible_vals(sudoku_c, size, sudoku_possible_vals_c, row, col, only_one_possible)
                cutoffs_for_sudoku(sudoku_c, sudoku_possible_vals_c, no_value_c, size, only_one_possible)

                #O(n)
                no_value_c.remove((row, col))

                sudoku_c, num_nodes = sudoku_recursive(sudoku_c, sudoku_possible_vals_c, no_value_c, num_nodes, size)

                if sudoku_c is not None:
                    return sudoku_c, num_nodes
                else:
                    if i == len(possible) - 1:
                        return None, num_nodes
        else:
            return None, num_nodes

def find_smallest_possible(sudoku_possible_vals, no_value):
    min = no_value[0]
    #O(n)
    for row, col in no_value:
        if len(sudoku_possible_vals[row][col]) < len(sudoku_possible_vals[min[0]][min[1]]):
            min = (row, col)
            if len(min) == 2:
                return min
    return min

def update_possible_vals(sudoku, size, sudoku_possible_vals, row, col, only_one_possible):
    square_val = sudoku[row][col]
    
    if square_val != None:

        # removing the possible vals in row
        for c in range(size):
            sudoku_possible_vals[row][c].discard(int(square_val))
            if len(sudoku_possible_vals[row][c]) == 1:
                only_one_possible.append((row, c))

        # removing the possible vals in col
        for r in range(size):
            sudoku_possible_vals[r][col].discard(int(square_val))
            if len(sudoku_possible_vals[r][col]) == 1:
                only_one_possible.append((r, col))

        # removing by the inner square
        row_start = int((row // sqrt(size)) * sqrt(size))
        col_start = int((col// sqrt(size)) * sqrt(size))

        for r in range(row_start, row_start + int(sqrt(size))):
            for c in range(col_start, col_start + int(sqrt(size))):
                sudoku_possible_vals[r][c].discard(int(square_val))
                if len(sudoku_possible_vals[r][c]) == 1:
                    only_one_possible.append((r, c))


def get_possible_vals(sudoku, size, sudoku_possible_vals, no_value):
    """
    Calls update_possible_vals() works as the driver
    """
    only_one_possible = []

    # update the possible vals for every cell
    for row in range(size):
        for col in range(size):
            if sudoku[row][col] != None:
                update_possible_vals(sudoku, size, sudoku_possible_vals, row, col, only_one_possible)

    return only_one_possible

def cutoffs_for_sudoku(sudoku, sudoku_possible_vals, no_value, size, only_one_possible):
    while len(only_one_possible) > 0:
        temp = only_one_possible.pop()
        if (len(sudoku_possible_vals[temp[0]][temp[1]]) != 0):
            #O(n)
            no_value.remove((temp[0], temp[1]))
            sudoku[temp[0]][temp[1]] = (str)(sudoku_possible_vals[temp[0]][temp[1]].pop())
            update_possible_vals(sudoku, size, sudoku_possible_vals, temp[0], temp[1], only_one_possible)

    for item in no_value:
        for val in sudoku_possible_vals[item[0]][item[1]]:
            # checking by row
            count = 0
            for c in range(size):
                if val not in sudoku_possible_vals[item[0]][c]:
                    count += 1
                else:
                    c = size
                    #How can we break out of this loop once we know that this cutoff isnt guaranteed

            if count == size - 1:
                sudoku[item[0]][item[1]] = str(val)
                sudoku_possible_vals[item[0]][item[1]] = set()
                no_value.remove(item)
                update_possible_vals(sudoku, size, sudoku_possible_vals, item[0], item[1], only_one_possible)
                cutoffs_for_sudoku(sudoku, sudoku_possible_vals, no_value, size, only_one_possible)

    for item in no_value:
        for val in sudoku_possible_vals[item[0]][item[1]]:
            # checking by col
            count = 0
            for r in range(size):
                if val not in sudoku_possible_vals[r][item[1]]:
                    count += 1
                else:
                    r = size

            if count == size - 1:
                sudoku[item[0]][item[1]] = str(val)
                sudoku_possible_vals[item[0]][item[1]] = set()
                no_value.remove(item)
                update_possible_vals(sudoku, size, sudoku_possible_vals, item[0], item[1], only_one_possible)
                cutoffs_for_sudoku(sudoku, sudoku_possible_vals, no_value, size, only_one_possible)    

    for item in no_value:
        row_start = int((item[0] // sqrt(size)) * sqrt(size))
        col_start = int((item[1]// sqrt(size)) * sqrt(size))
        
        for val in sudoku_possible_vals[item[0]][item[1]]:
            # checking by subsquare
            count = 0
            for r in range(row_start, row_start + int(sqrt(size))):
                for c in range(col_start, col_start + int(sqrt(size))):
                    if val not in sudoku_possible_vals[r][c]:
                        count += 1   
            
            if count == size - 1:
                sudoku[item[0]][item[1]] = str(val)
                sudoku_possible_vals[item[0]][item[1]] = set()
                no_value.remove(item)
                update_possible_vals(sudoku, size, sudoku_possible_vals, item[0], item[1], only_one_possible)
                cutoffs_for_sudoku(sudoku, sudoku_possible_vals, no_value, size, only_one_possible)

def read_input_file(input_filename, size):
    """
    Reads the input file, and returns a 2d array with the predefined values and a list of tuples with grid locations of unset values
    """

    f = open(input_filename)

    no_value = [(x, y) for x in range(0, size) for y in range(0, size)]

    
    # initiating all values to be None
    sudoku = []
    for i in range(size):
        row = [None] * size
        sudoku.append(row)

    # filling in predfined values
    for line in f:
        line_entries = line.strip().split()
        row = int(line_entries[0])
        col = int(line_entries[1])
        val = line_entries[2].strip()
        sudoku[row-1][col-1] = val

        no_value.remove((row-1, col-1))

    return sudoku, no_value


if __name__ == "__main__":
    print(solve(9, "p2.txt"))
